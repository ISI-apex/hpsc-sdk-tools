QEMU=qemu
QEMU_DT=qemu-devicetrees

# Available only on the Zebu server
ZEBU=zebu
ZEBU_SHELL=csh
ZEBU_ENV=$(abspath $(ZEBU)/zebu_setup.sh)

BLD=bld
BLD_TO_ROOT=..
FETCH=$(BLD)/fetch
FETCH_CACHE?=$(FETCH)
TC=$(BLD)/tc
WORK=$(BLD)/work
BLD_QEMU=$(BLD)/qemu
INSTALL_QEMU=$(BLD)/qemu-install
BLD_QEMU_TO_ROOT=$(BLD_TO_ROOT)/..
SDK_TOOLS=hpsc-sdk-tools
SYSROOT=$(SDK_TOOLS)/sysroot

# Sysroot for binary toolchains (not to be confused with hpsc-sdk-tools/sysroot)
TC_SYSROOT=$(BLD)/sysroot
TC_PREFIX=$(TC_SYSROOT)/usr

BIN_SYSROOT=$(BLD)/bin
BIN_PREFIX=$(BIN_SYSROOT)/usr

# Host tools needed to build the SDK (not including deps of nested builds)
WGET=wget
TAR=tar

# pre-built toolchains are linked against a libc, so we must have at least that version
LIBC_MIN_VERSION=2.14
LIBC_VERSION=$(shell ldd --version | head -1 | grep -o '[0-9]\+\(\.[0-9]\+\)\+')

all: binaries tools toolchains env qemu qemu-dt sysroot
clean: binaries-clean tools-clean toolchains-clean env-clean \
		qemu-clean qemu-dt-clean sysroot-clean

# Prerequisites added to this rule dynamically
fetch: toolchains-fetch sysroot-fetch tools-sysroot-fetch

TC_PATHS=$(foreach t,$(DEPS_TC),$(TC)/$(DIR_$(t))/bin)
SPACE=$(subst ,, )
PATHS=$(subst $(SPACE),:,$(abspath \
	$(SDK_TOOLS)/bin \
	$(ZEBU)/bin \
	$(BLD_QEMU) \
	$(BLD_QEMU)/aarch64-softmmu \
	$(BIN_PREFIX)/bin \
	$(TC_PATHS)))

define ENV
export PATH="$(PATHS):$$PATH"
export QEMU_DT="$(abspath $(QEMU_DT))"
export QEMU_DT_SRC="hpsc-arch.dts"
export QEMU_DT_FILE="$$QEMU_DT/LATEST/SINGLE_ARCH/hpsc-arch.dtb"
export ZEBU="$(abspath $(ZEBU))"
export ZEBU_ENV="$(abspath $(ZEBU_ENV))"
export ZEBU_SHELL="$(ZEBU_SHELL)"
endef

env: $(BLD)/env.sh
$(BLD)/env.sh: export ENV_SH=$(ENV)
$(BLD)/env.sh: $(BLD)/dep-env.sh | $(BLD)/.
	@echo "# Autogenerated environment file for using the SDK" > $@
	cat $^ >> $@
	echo "$$ENV_SH" >> $@
env-clean:
	rm -f $(BLD)/env.sh
.PHONY: env env-clean

DEPS_TC=\
	arm_gnu_rm \
	arm_gnu_a \

TC_SYSROOT_LIBS=\
	glibc \
	zlib \

RELOCATE_TC=$(if $(call version-lt,$(LIBC_VERSION),$(LIBC_MIN_VERSION)),1)

DEPS_TC_SYSROOT=$(if $(RELOCATE_TC),$(TC_SYSROOT_LIBS))

DEPS_BIN=\
	$(DEPS_TC_SYSROOT) \
	gdb \

DEPS=$(DEPS_BIN) $(DEPS_TC)

# Other toolchain distributables may work as well, with the known exceptions:
# * GCC v8 breaks build of kernel 4.14 (build completes but kernel does not run)
# * gcc-arm-none-eabi v8 (from ARM, not Linaro) breaks build of M4,R52 bare metal
# * gcc-arm-none-eabi older than v7 2018-q2-update breaks build of R52 bare metal

VER_arm_gnu_rm=7-2018-q2-update
URL_arm_gnu_rm=https://developer.arm.com/-/media/Files/downloads/gnu-rm/7-2018q2
TARBALL_arm_gnu_rm=gcc-arm-none-eabi-$(VER_arm_gnu_rm)-linux.tar.bz2
DIR_arm_gnu_rm=gcc-arm-none-eabi-$(VER_arm_gnu_rm)

VER_arm_gnu_a=7.4.1-2019.02
URL_arm_gnu_a=https://releases.linaro.org/components/toolchain/binaries/latest-7/aarch64-linux-gnu
TARBALL_arm_gnu_a=gcc-linaro-$(VER_arm_gnu_a)-x86_64_aarch64-linux-gnu.tar.xz
DIR_arm_gnu_a=gcc-linaro-$(VER_arm_gnu_a)-x86_64_aarch64-linux-gnu

# glibc >= 2.14 is required by pre-built toolchains
# ...but glibc >=2.21 needs GCC >= 4.6; glibc >= 2.20 needs GCC >= 4.4)
VER_glibc=2.20
URL_glibc=https://ftp.gnu.org/gnu/libc
TARBALL_glibc=glibc-$(VER_glibc).tar.xz
DIR_glibc=glibc-$(VER_glibc)
ART_glibc=$(TC_PREFIX)/lib/libc.so

VER_zlib=1.2.11
URL_zlib=https://www.zlib.net
TARBALL_zlib=zlib-$(VER_zlib).tar.xz
DIR_zlib=zlib-$(VER_zlib)
ART_zlib=$(TC_PREFIX)/lib/libz.so

# Build GDB with multi-arch support
VER_gdb=8.3
URL_gdb=https://ftp.gnu.org/gnu/gdb
TARBALL_gdb=gdb-$(VER_gdb).tar.xz
DIR_gdb=gdb-$(VER_gdb)
ART_gdb=$(BIN_PREFIX)/bin/gdb

$(ART_glibc):
	mkdir -p $(DIR)/build
	cd $(DIR)/build && ../configure --prefix=$(abspath $(TC_PREFIX))
	$(MAKE) -C $(DIR)/build
	$(MAKE) -C $(DIR)/build install

$(ART_zlib):
	cd $(DIR) && ./configure --prefix=$(abspath $(TC_PREFIX))
	$(MAKE) -C $(DIR)
	$(MAKE) -C $(DIR) install

$(ART_gdb):
	cd $(DIR) && ./configure --prefix=$(abspath $(BIN_PREFIX)) \
		--enable-targets=arm-none-eabi,aarch64-none-linux-,x86_64-none-linux- \
		--enable-languages=c \
		--enable-multilib --enable-interwork --disable-nls \
		--with-python=/usr/bin/python3 --with-guile=guile-2.0
	$(MAKE) -C $(DIR)
	$(MAKE) -C $(DIR) install

# Ideally, this would be "%/:" but make <=3.81 eats trailing slashes
%/. :
	mkdir -p $@

define fetch-rule
$(FETCH_CACHE)/$(TARBALL_$(1)): | $(FETCH_CACHE)/.
	$(WGET) --no-verbose -O $$@ $(URL_$(1))/$$(@F)
.INTERMEDIATE: $(FETCH_CACHE)/$(TARBALL_$(1))
.SECONDARY: $(FETCH_CACHE)/$(TARBALL_$(1))
endef

# We make a copy, so that we're self-sufficient in case FETCH_CACHE goes away
ifneq ($(patsubst %.,%,$(FETCH)),$(FETCH_CACHE)) # strip . from /. (see mkdir rule)
# This mkdir rule is so that $(FETCH)/% doesn't match $(FETCH)/. and create
# a circular dependency. This is only needed with the /. workaround (see mkdir rule)
$(FETCH)/.:
	mkdir -p $@
$(FETCH)/%: $(FETCH_CACHE)/% | $(FETCH)/.
	cp $< $@
endif
.SECONDARY: $(FETCH)/.

# touch the directory, since the timestamp of the dir in tar may be stored and
# it will be older than the tarball, which would cause the target to be remade.
define extract-rule
$(2)/$(DIR_$(1)): $(FETCH)/$(TARBALL_$(1)) | $(2)/.
	$(TAR) -C $(2) -x -f $$<
	touch $$@
$(1) : | $(2)/$(DIR_$(1))
endef
.PHONY: sysroot

define sysroot-clean-rule
$(1)-clean:
	rm -rf $(WORK)/$(DIR_$(1)) $(ART_$(1))
.PHONY: $(1)-clean
endef

define tc-relocate-rule
tc-$(1)-relocate: $(TC)/$(DIR_$(1)) $(ART_glibc)
	find $(TC)/$(DIR_$(1)) -type f -executable -not -name '*.so*' -exec \
		patchelf --set-interpreter $(abspath $(TC_PREFIX)/lib/ld-$(VER_glibc).so) \
		--set-rpath $(abspath $(TC_PREFIX)/lib) {} \;
$(1): tc-$(1)-relocate
endef

$(foreach d,$(DEPS),$(eval $(call fetch-rule,$(d))))
$(foreach d,$(DEPS_TC),\
	$(eval $(call extract-rule,$(d),$(TC)))\
	$(eval $(if $(RELOCATE_TC),$(call tc-relocate-rule,$(d),$(TC)))))
$(foreach d,$(DEPS_BIN),\
	$(eval $(call extract-rule,$(d),$(WORK)))\
	$(eval $(call sysroot-clean-rule,$(d))))

# Make extract target a prereq of build/install target
$(foreach d,$(DEPS),$(eval $(ART_$(d)): | $(WORK)/$(DIR_$(d))))

# Alias for each dependency, that points to the artifact
$(foreach d,$(DEPS_BIN),$(eval $(d): $(ART_$(d))))

# Define per-target DIR to allow recipies to be more concise
$(foreach d,$(DEPS),$(eval $(ART_$(d)): DIR=$(WORK)/$(DIR_$(d))))

toolchains: $(DEPS_TC)
toolchains-fetch: $(foreach tc,$(DEPS_TC),$(FETCH)/$(TARBALL_$(tc)))
toolchains-clean:
	rm -rf $(TC)/
.PHONY: toolchains-clean

sysroot: $(DEPS_TC_SYSROOT)
sysroot-clean: $(foreach d,$(DEPS_TC_SYSROOT),$(d)-clean)
sysroot-fetch: $(foreach d,$(DEPS_TC_SYSROOT),$(FETCH)/$(TARBALL_$(d)))
.PHONY: sysroot sysroot-clean

binaries: $(DEPS_BIN)
binaries-clean: $(foreach d,$(DEPS_BIN),$(d)-clean)
.PHONY: binaries binaries-clean

# Several alternatives for installing dependencies

# We can't make this choice for the user -- that is, DEP_ENV_FILE has to be
# makeable only by a phony target. Also, help if deps-* wasn't run.
$(BLD)/dep-env.sh:
	@echo "ERROR: must build dependency target first:"
	@echo "  supported options (pick one): deps-sysroot deps-centos7"
	@echo "  to reset and choose again: deps-clean"
	exit 1
deps-clean:
	rm -f $(BLD)/dep-env.sh
.PHONY: deps-clean

deps-centos7: | $(BLD)/.
	sudo yum install -y https://centos7.iuscommunity.org/ius-release.rpm
	sudo yum update
	sudo yum group install "Development Tools"
	sudo yum install java git gtk3 chrpath texinfo screen glib2-devel libfdt-devel \
		pixman-devel zlib-devel uboot-tools bc ncurses-devel python-configparser \
		python36u python36u-libs python36u-devel python36u-pip pax python-sphinx \
		guile guile-devel
	sudo ln -sf /usr/bin/python3.6 /usr/bin/python3
	sudo yum install cairo-devel cairo-gobject-devel gobject-introspection-devel \
		pygobject2 pygboject2-devel
	echo > $(BLD)/dep-env.sh
.PHONY: deps-centos7

deps-arch: | $(BLD)/.
	sudo pacman -S --needed base-devel git screen python python2 \
		uboot-tools glib2 pixman zlib ncurses wget dtc bc gmp guile2.0 \
		chrpath cpio diffstat rpcsvc-proto
	which pacaur # if not installed, please install pacaur manually
	pacaur -S --needed pax
	echo > $(BLD)/dep-env.sh
.PHONY: deps-arch

deps-sysroot: tools-sysroot | $(BLD)/.
	echo 'source $(abspath $(SYSROOT)/bld/env.sh)' > $(BLD)/dep-env.sh
.PHONY: deps-sysroot

# Components of the SDK that are built from source

tools: tools-all
tools-%:
	$(MAKE) -C $(SDK_TOOLS) FETCH_CACHE=$(abspath $(FETCH_CACHE)) $*
.PHONY: tools-%

# Build Qemu s.t. its GDB stub points to the given target CPU cluster:
# TRCH=0, RTPS_R52=1, RTPS_A53=2, HPPS=3
QEMU_GDB_TARGET_CLUSTER=3

QEMU_ARGS=
$(BLD_QEMU)/config.status: | $(BLD_QEMU)/.
	cd $(BLD_QEMU) && CFLAGS+=-DGDB_TARGET_CLUSTER=$(QEMU_GDB_TARGET_CLUSTER) \
		$(BLD_QEMU_TO_ROOT)/$(QEMU)/configure \
		--prefix=$(abspath $(INSTALL_QEMU)) \
		--python=$$(which python2) \
		--target-list=aarch64-softmmu --enable-fdt \
		--disable-kvm --disable-xen --enable-debug
# TODO: add install-doc target (requires Sphynx 1.3, not in CentOS 7)
qemu: $(BLD_QEMU)/config.status qemu-bin
	$(MAKE) -C $(BLD_QEMU) $(QEMU_ARGS) install
qemu-bin: $(BLD_QEMU)/config.status
	$(MAKE) -C $(BLD_QEMU) $(QEMU_ARGS)
qemu-sclean:
	$(MAKE) -C $(BLD_QEMU) $(QEMU_ARGS) clean
qemu-clean:
	rm -rf $(BLD_QEMU) $(INSTALL_QEMU)
.PHONY: qemu qemu-sclean qemu-clean

QDT_ARGS=
$(QEMU_DT)/LATEST/SINGLE_ARCH/hpsc-arch.dtb: qemu-dt
qemu-dt:
	$(MAKE) -C $(QEMU_DT) $(QDT_ARGS)
qemu-dt-clean:
	$(MAKE) -C $(QEMU_DT) $(QDT_ARGS) clean
.PHONY: qemu-dt qemu-dt-clean

zebu:
	$(ZEBU_SHELL) -c 'source $(ZEBU_ENV) && make -C $(ZEBU)'
zebu-clean:
	$(ZEBU_SHELL) -c 'source $(ZEBU_ENV) && make -C $(ZEBU) clean'
.PHONY: zebu zebu-clean

define version-lt
$(filter-out $(2),$(firstword $(sort $(1) $(2))))
endef # version-lt
