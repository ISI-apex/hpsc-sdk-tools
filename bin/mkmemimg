#!/usr/bin/env python3

import os
import re
import argparse

from memmap import MemMap
from inicfg import IniCfg

parser = argparse.ArgumentParser(
    description="Compose a binary memory image from files defined in a memory map")
parser.add_argument('map_file',
    help='Input file with memory map')
parser.add_argument('--config', '-c', required=True,
    help='Input file with size and layout parameters in INI format')
parser.add_argument('--memory', '-m', required=True,
    help='Name of memory for which to create image (a section in config file)')
parser.add_argument('--output', '-o', required=True,
    help='Output filename where to save the binary image')
args = parser.parse_args()

class MkMemImgException(Exception):
    def __init__(self, message, line=0):
        self.line = line
        self.message = message

def size_from_iec_str(s):
    m = re.match(r'([0-9]+)([KMG]?)', s)
    if not m:
        raise MkMemImgException("size not in IEC format: '%s'" % s)
    size = int(m.group(1))
    suffix = m.group(2)
    if suffix == 'G':
        size <<= 30
    if suffix == 'M':
        size <<= 20
    if suffix == 'K':
        size <<= 10
    return size

def make_bin_image(fout, fmap_it, m, cgf, fmt):
    size, = cfg.get_props(m, 'size')
    size = size_from_iec_str(size)
    fout.truncate(size)
    for line, k, addr, fname in fmap_it:
        addr = int(addr, 16)
        fin = open(fname, "rb")
        if fmt == "bin":
            fout.seek(addr)
            while True:
                d = fin.read(4096)
                if len(d) == 0:
                    break
                fout.write(d)
        elif fmt == "vhex":
            print("@%x" % addr, file=fout)
            # TODO: re-use hpsc-objcopy's classes
            raise MkMemImgException("NOT IMPLEMENTED: sparse vhex format", line)
        else:
            raise MkMemImgException("unsupported image format: %s" % fmt, line)
        fin.close()

def make_nand_image(fout, fmap_it, m, cfg):
    blocks, ppb, page, oob = cfg.get_props(m, 'blocks', 'ppb', 'page', 'oob')
    s = int(blocks) * int(ppb) * (int(page) + int(oob))
    print("Creating NAND image of size:", s, "bytes =", float(s) / (1<<20), " MB")
    buf = b'\xFF' * 4096
    while s > 0:
        if s > len(buf):
            fout.write(buf)
            s -= len(buf)
        else:
            fout.write(b'\xFF' * s)
            s -= s

    for line, k, addr, fname in fmap_it:
        addr = int(addr, 16)
        fout.seek(addr)
        fin = open(fname, "rb")
        while True:
            d = fin.read(4096)
            if len(d) == 0:
                break
            fout.write(d)

try:
    fmap = open(args.map_file, "r")
    cfg = IniCfg(args.config)

    fmt, = cfg.get_props(args.memory, 'image_format')
    if fmt == "raw": # alias
        fmt = "bin"

    fout = open(args.output, "wb")
    fmap_it = MemMap.iter_mem(fmap, args.memory)
    try:
        if fmt in ["raw", "bin", "vhex"]:
            make_bin_image(fout, fmap_it, args.memory, cfg, fmt)
        elif fmt in ["nand.bin", "nand.raw"]:
            make_nand_image(fout, fmap_it, args.memory, cfg)
        else:
            raise MkMemImgException(
                "invalid image format for memory '%s': %s" % (args.memory, fmt))

    except MkMemImgException as e:
        raise MkMemImgException("%s:%u: %s" % (args.map_file, e.line, e.message)) from e
    except Exception as e:
        raise MkMemImgException("%s: exception" % (args.map_file)) from e

    fmap.close()
    fout.close()

except: # when used from makefiles, important to not create output on failure
    os.remove(args.output)
    raise
