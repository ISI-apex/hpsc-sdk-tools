#!/bin/bash

# Construct the QEMU command line and invoke it
#
# Expects SDK to have been activated by loading
# the SDK env.sh script into the shell.
#
# Dependencies:
#   * screen : for display of forwarded serial UART ports
#   * Python 2: with the following modules
#      - telnetlib : for communication with Qemu via QMP interface
#      - json : for QMP

function finish {
    if [ -n "$GDB_CMD_FILE" ]
    then
        rm "$GDB_CMD_FILE"
    fi
    if [ ! -z "$CONSOLES_PID" ]
    then
        if ps -p "$CONSOLES_PID" >/dev/null 2>&1
        then
            kill "$CONSOLES_PID"
        fi
    fi
}
trap finish EXIT

function source_if_exists()
{
    if [ -f "$1" ]
    then
        echo "Loading env from: $1"
        source "$1"
    fi
}

# Allow overriding settings (most of which settable via command line)
ENV_FILES=("${PWD}/qemu-env.sh")

parse_addr() {
    echo "$1" | sed 's/_//g'
}
hex() {
    printf "0x%x" "$1"
}
extract_word() {
    local IDX=$1
    shift
    local i=0
    for w in "$@"
    do
        if [ $i -eq "$IDX" ]
        then
            echo "$w"
            return
        fi
        i=$((i + 1))
    done
}

function nand_blocks() {
    local size=$1
    local page_size=$2
    local pages_per_block=$3
    echo $(( size / (pages_per_block * page_size) ))
}

function set_default()
{
   local name="$1"
   local val="$2"
   # Check for set/unset not emptiness to let empty carry meaning
   if [ ! "${!name+_}" ]
   then
      declare -g "$name=$val"
   fi
}

run() {
    echo "$@"
    "$@"
}

function create_sram_image()
{
    run sram-image-utils create "$1" "$2"
    run sram-image-utils show "$1"
}

create_nand_image()
{
    local file=$1
    local size=$2
    local page_size=$3
    local pages_per_block=$4
    local oob_size=$5
    local ecc_size=$6
    local blocks="$(nand_blocks "$size" "$page_size" "$pages_per_block")"
    run qemu-nand-creator "$page_size" "$oob_size" "$pages_per_block" "$blocks" "$ecc_size" 1 "$file"
}

create_if_absent()
{
    local dest=$1
    local src=$2
    local overwrite=$3
    local creator=$4
    shift 4
    if [[ ! -f "$dest" || "$overwrite" -eq 1 ]]
    then
        if [ -f "$src" ]
        then
            echo "Overwriting memory image..."
            run cp "$src" "$dest"
        else
            echo "Creating memory image..."
            $creator "$dest" "$@"
        fi
    else
        echo "Using existing memory image: $dest"
    fi
}

create_images()
{
    set -e
    create_if_absent "${TRCH_SRAM_FILE0}" "${TRCH_SMC_SRAM0}" "${TRCH_SMC_SRAM_OVERWRITE}" \
        create_sram_image "${LSIO_SRAM_SIZE0}"
    create_if_absent "${TRCH_SRAM_FILE1}" "${TRCH_SMC_SRAM1}" "${TRCH_SMC_SRAM_OVERWRITE}" \
        create_sram_image "${LSIO_SRAM_SIZE1}"
    create_if_absent "${TRCH_SRAM_FILE2}" "${TRCH_SMC_SRAM2}" "${TRCH_SMC_SRAM_OVERWRITE}" \
        create_sram_image "${LSIO_SRAM_SIZE2}"
    create_if_absent "${TRCH_SRAM_FILE3}" "${TRCH_SMC_SRAM3}" "${TRCH_SMC_SRAM_OVERWRITE}" \
        create_sram_image "${LSIO_SRAM_SIZE3}"
    create_if_absent "${TRCH_NAND_FILE0}" "${TRCH_SMC_NAND0}" "${TRCH_SMC_NAND_OVERWRITE}" \
        create_nand_image "$TRCH_NAND_SIZE0" "$TRCH_NAND_PAGE_SIZE0" "$TRCH_NAND_PAGES_PER_BLOCK0" \
                "$TRCH_NAND_OOB_SIZE0" "$TRCH_NAND_ECC_SIZE0"
    create_if_absent "${HPPS_SRAM_FILE0}" "${HPPS_SMC_SRAM0}" "${HPPS_SMC_SRAM_OVERWRITE}" \
        create_sram_image "${HPPS_SRAM_SIZE0}"
    create_if_absent "${HPPS_NAND_FILE0}" "${HPPS_SMC_NAND0}" "${HPPS_SMC_NAND_OVERWRITE}" \
        create_nand_image "$HPPS_NAND_SIZE0" "$HPPS_NAND_PAGE_SIZE0" "$HPPS_NAND_PAGES_PER_BLOCK0" \
                "$HPPS_NAND_OOB_SIZE0" "$HPPS_NAND_ECC_SIZE0"
    set +e
}

function usage()
{
    echo "Usage: $0 [-hSq] [-d dt_file] [-e env]* [-m mem] [-n netcfg [-p port]*] [ cmd ]" 1>&2
    echo "               cmd: command" 1>&2
    echo "                    run - start emulation (default)" 1>&2
    echo "                    gdb - launch the emulator in GDB" 1>&2
    echo "               -d dt_file: Qemu device tree file that defines the machine" 1>&2
    echo "               -e env: load environment settings from file" 1>&2
    echo "               -m memory map: preload files into memory" 1>&2
    echo "               -n netcfg : choose networking configuration" 1>&2
    echo "                   user: forward a port on the host to the target NIC" 1>&2
    echo "                   tap: create a host tunnel interface to the target NIC (requires root)" 1>&2
    echo "               -p port: in 'user' networking config, forward port to host" 1>&2
    echo "                    (script prints host port assigned to each forwarded port)" 1>&2
    echo "               -S : wait for GDB or QMP connection instead of resetting the machine" 1>&2
    echo "               -q : do not enable the Qemu monitor prompt" 1>&2
    echo "               -h : show this message" 1>&2
    exit 1
}

function setup_screen()
{
    local SESSION=$1

    if [ "$(screen -list "$SESSION" | grep -c "$SESSION")" -gt 1 ]
    then
        # In case the user somehow ended up with more than one screen process,
        # kill them all and create a fresh one.
        echo "Found multiple screen sessions matching '$SESSION', killing..."
        screen -list "$SESSION" | grep "$SESSION" | \
            sed -n "s/\([0-9]\+\).$SESSION\s\+.*/\1/p" | xargs kill
    fi

    # There seem to be some compatibility issues between Linux distros w.r.t.
    # exit codes and behavior when using -r and -q with -ls for detecting if a
    # user is attached to a session, so we won't bother trying to wait for them.
    screen -q -list "$SESSION"
    # it's at least consistent that no matching screen sessions gives $? < 10
    if [ $? -lt 10 ]
    then
        echo "Creating screen session with console: $SESSION"
        screen -d -m -S "$SESSION"
    fi
}

function serial_ptys()
{
    qemu-chardev-ptys localhost "$QMP_PORT" "${!SCREEN_SESSIONS[@]}"
}

function attach_consoles()
{
    echo "Waiting for Qemu to open QMP port and to query for PTY paths..."
    #while test $(lsof -ti :$QMP_PORT | wc -l) -eq 0
    while true
    do
        PTYS="$(serial_ptys 2>/dev/null)"
        if [ -z "$PTYS" ]
        then
            #echo "Waiting for Qemu to open QMP port..."
            sleep 1
            ATTEMPTS+=" 1 "
            if [ "$(echo "$ATTEMPTS" | wc -w)" -eq 10 ]
            then
                echo "ERROR: failed to get PTY paths from Qemu via QMP port: giving up."
                echo "Here is what happened when we tried to get the PTY paths:"
                set -x
                serial_ptys
                exit # give up to not accumulate waiting processes
            fi
        else
            break
        fi
    done

    declare -A "PTYS_DICT=$PTYS" # port label => desired session name
    for p in ${!PTYS_DICT[@]}
    do
        # Need to start a new single-use $pty_sess screen session outside of the
        # persistent $sess one, then attach to $pty_sess from within $sess.
        # This is needed if $sess was previously attached, then detached (but
        # not terminated) after QEMU exited.
        local pty="${PTYS_DICT[$p]}"
        local sess="${SCREEN_SESSIONS[$p]}"
        local pty_sess="hpsc-pts$(basename "$pty")"
        echo "Adding console $pty for port $p to screen session $sess"
        screen -d -m -S "$pty_sess" "$pty"
        screen -S "$sess" -X screen screen -m -r "$pty_sess"
        sleep 1 # give the above command time to execute
        echo "Attach to screen session from another window with:"
        echo "  screen -r $sess"
    done

    echo "Commanding Qemu to reset the machine..."
    if [ "$RESET" -eq 1 ]
    then
        echo "Sending 'continue' command to Qemu to reset the machine..."
        qmp-cmd localhost "$QMP_PORT" cont
    else
        echo "Waiting for 'continue' (aka. reset) command via GDB or QMP connection..."
    fi
}

setup_console()
{
    for session in "${SCREEN_SESSIONS[@]}"
    do
        setup_screen "$session"
    done
    if [ "${#SCREEN_SESSIONS[@]}" -gt 0 ]
    then
        attach_consoles &
        CONSOLES_PID=$!
    fi
}

preload_memory()
{
    set -e
    local map_file=$1
    echo "Preloading memory according to map file: $map_file"
    if [ ! -r "${map_file}" ] # 'while...done < file' not fatal even with set -e
    then
        echo "ERROR: can't read preload memory map file: $map_file" 1>&2
        return 1
    fi
    declare -A SEGMENT_ADDRS
    declare -A SEGMENT_FILES
    local line_num=0
    while read line
    do
        local HASH="#" # workaround for vim syntax highlightin breaking
        if [[ "$line" =~ ^\s*$ || "$line" =~ ^[[:space:]]*$HASH ]]
        then
            continue
        fi
        line=$(echo "$line" | sed 's/\(.*\)\s*#.*/\1/')
        local WORDS=($line)

        local key=$(extract_word 0 "${WORDS[@]}")
        local addr_spec=$(extract_word 1 "${WORDS[@]}")
        local in_file=$(eval echo "$(extract_word 2 "${WORDS[@]}")") # expand vars

        if [[ -z "$key" || -z "$addr_spec" || -z "$in_file" ]]
        then
            echo "ERROR: syntax error on line $line_num" 1>&2
            exit 2
        fi

        # Address field can be: 0x00000000, 0x0000_0000, after(name), -, 4:<any of the above>
        addr_spec=$(echo "$addr_spec" | sed 's/(/\[/g' | sed 's/)/\]/g') # ()->[] for eval
        addr_spec=$(eval echo "$addr_spec")
        addr_spec=$(echo "$addr_spec" | sed 's/_//g')
        local cpu="$(echo "$addr_spec" | sed -n 's/^\([0-9]\+\):.*/\1/p')" # may be empty
        addr_spec="$(echo "$addr_spec" | sed -n 's/^\([0-9]\+:\)\?\(.*\)/\2/p')"
        local ref_seg=$(echo "$addr_spec" | sed -n 's/^after\[\([^)]\+\)\]/\1/p')
        if [ ! -z "$ref_seg" ]
        then
            local addr=$(hex $((${SEGMENT_ADDRS[$ref_seg]} + $(stat -c '%s' "${SEGMENT_FILES[$ref_seg]}"))))
        else
            if [[ "$addr_spec" =~ - ]]
            then  # do not supply addr
                local addr=
            else
                local addr=$(parse_addr "$(echo "$addr_spec" | sed -n 's/^\(0x\)\?\([0-9A-Fa-f]\+\)/\1\2/p')")
            fi
        fi
        SEGMENT_ADDRS["$key"]="$addr"
        SEGMENT_FILES["$key"]="$in_file"

        local loader_arg="loader,file=$in_file"
        if [ ! -z "$cpu" ]
        then
            loader_arg+=",cpu-num=$cpu"
        fi
        if [ ! -z "$addr" ]
        then
            loader_arg+=",force-raw,addr=$addr"
        fi
        COMMAND+=(-device "$loader_arg")

        line_num=$((line_num + 1))
    done < "$map_file"
    set +e
}

# defaults
RESET=1
NET=none
MONITOR=1
FWD_PORTS=()
MEMORY_FILES=()

# parse options
while getopts "h?S?q?e:d:m:p:n:" o; do
    case "${o}" in
        S)
            RESET=0
            ;;
        d)
            QEMU_DT_FILE="$OPTARG"
            ;;
        e)
            ENV_FILES+=("$OPTARG")
            ;;
        p)
            FWD_PORTS+=("$OPTARG")
            ;;
        m)
            MEMORY_FILES+=("$OPTARG")
            ;;
        n)
            NET="$OPTARG"
            ;;
        q)
            MONITOR=0
            ;;
        h)
            usage
            ;;
        *)
            echo "Wrong option" 1>&2
            usage
            ;;
    esac
done
shift $((OPTIND-1))
CMD=$*

if [ -z "${CMD}" ]
then
    CMD="run"
fi

## Configurable params of array types (must be inited before loading env)
#
# Note: all are overridable in an env.sh file.
# Note: params of array types are not overridable via environment variables.

declare -A SERIAL_PORT_NAMES

for qemu_env in "${ENV_FILES[@]}"
do
    echo "QEMU ENV ${qemu_env}"
    source_if_exists "${qemu_env}"
done

# Privatize ports and screen sessions for this Qemu instance
: "${ID:=0}"

# Memory images created by this script will go here
: "${RUN_DIR:=.}"
mkdir -p "${RUN_DIR}"

: "${LOG_FILE:=/tmp/qemu-$(whoami).log}"
: "${BRIDGE:=br0}"
: "${HOST_BIND_IP:=127.0.0.1}"

# This maximum is respected by Qemu, regardless of what memory is defined in
# Qemu device tree (e.g. generic-loader will fail to load a file that exceeds
# this maximum, even if DT defines larger memory).
: "${MAX_VM_MEM:=4G}"

# Size of off-chip memory connected to SMC SRAM ports,
# this size is used if/when this script creates the images.
: "${LSIO_SRAM_SIZE0:=0x02000000}"           #  32MB
: "${LSIO_SRAM_SIZE1:=0x02000000}"           #  32MB
: "${LSIO_SRAM_SIZE2:=0x02000000}"           #  32MB
: "${LSIO_SRAM_SIZE3:=0x02000000}"           #  32MB
: "${HPPS_SRAM_SIZE0:=0x01000000}"           #  16MB
: "${HPPS_SRAM_SIZE1:=0x01000000}"           #  16MB
: "${HPPS_SRAM_SIZE2:=0x01000000}"           #  16MB
: "${HPPS_SRAM_SIZE3:=0x01000000}"           #  16MB
: "${HPPS_NAND_SIZE0:=0x10000000}"           # 256MB
: "${HPPS_NAND_PAGE_SIZE0:=2048}" # bytes
: "${HPPS_NAND_OOB_SIZE0:=64}" # bytes
: "${HPPS_NAND_ECC_SIZE0:=12}" # bytes
: "${HPPS_NAND_PAGES_PER_BLOCK0:=64}" # bytes
: "${HPPS_NAND_SIZE1:=0x10000000}"           # 256MB
: "${HPPS_NAND_PAGE_SIZE1:=2048}" # bytes
: "${HPPS_NAND_OOB_SIZE1:=64}" # bytes
: "${HPPS_NAND_ECC_SIZE1:=12}" # bytes
: "${HPPS_NAND_PAGES_PER_BLOCK1:=64}" # bytes
: "${HPPS_NAND_SIZE2:=0x10000000}"           # 256MB
: "${HPPS_NAND_PAGE_SIZE2:=2048}" # bytes
: "${HPPS_NAND_OOB_SIZE2:=64}" # bytes
: "${HPPS_NAND_ECC_SIZE2:=12}" # bytes
: "${HPPS_NAND_PAGES_PER_BLOCK2:=64}" # bytes
: "${HPPS_NAND_SIZE3:=0x10000000}"           # 256MB
: "${HPPS_NAND_PAGE_SIZE3:=2048}" # bytes
: "${HPPS_NAND_OOB_SIZE3:=64}" # bytes
: "${HPPS_NAND_ECC_SIZE3:=12}" # bytes
: "${HPPS_NAND_PAGES_PER_BLOCK3:=64}" # bytes
: "${TRCH_NAND_SIZE0:=0x10000000}"           # 256MB
: "${TRCH_NAND_PAGE_SIZE0:=2048}" # bytes
: "${TRCH_NAND_OOB_SIZE0:=64}" # bytes
: "${TRCH_NAND_ECC_SIZE0:=12}" # bytes
: "${TRCH_NAND_PAGES_PER_BLOCK0:=64}" # bytes
: "${TRCH_NAND_SIZE1:=0x10000000}"           # 256MB
: "${TRCH_NAND_PAGE_SIZE1:=2048}" # bytes
: "${TRCH_NAND_OOB_SIZE1:=64}" # bytes
: "${TRCH_NAND_ECC_SIZE1:=12}" # bytes
: "${TRCH_NAND_PAGES_PER_BLOCK1:=64}" # bytes
: "${TRCH_NAND_SIZE2:=0x10000000}"           # 256MB
: "${TRCH_NAND_PAGE_SIZE2:=2048}" # bytes
: "${TRCH_NAND_OOB_SIZE2:=64}" # bytes
: "${TRCH_NAND_ECC_SIZE2:=12}" # bytes
: "${TRCH_NAND_PAGES_PER_BLOCK2:=64}" # bytes
: "${TRCH_NAND_SIZE3:=0x10000000}"           # 256MB
: "${TRCH_NAND_PAGE_SIZE3:=2048}" # bytes
: "${TRCH_NAND_OOB_SIZE3:=64}" # bytes
: "${TRCH_NAND_ECC_SIZE3:=12}" # bytes
: "${TRCH_NAND_PAGES_PER_BLOCK3:=64}" # bytes

# Source files from which to init mem images (none by default)
: "{TRCH_SMC_SRAM0:=}"
: "{TRCH_SMC_SRAM1:=}"
: "{TRCH_SMC_SRAM2:=}"
: "{TRCH_SMC_SRAM3:=}"
: "{TRCH_SMC_NAND0:=}"
: "{TRCH_SMC_NAND1:=}"
: "{TRCH_SMC_NAND2:=}"
: "{TRCH_SMC_NAND3:=}"
: "{HPPS_SMC_SRAM0:=}"
: "{HPPS_SMC_SRAM1:=}"
: "{HPPS_SMC_SRAM2:=}"
: "{HPPS_SMC_SRAM3:=}"
: "{HPPS_SMC_NAND0:=}"
: "{HPPS_SMC_NAND1:=}"
: "{HPPS_SMC_NAND2:=}"
: "{HPPS_SMC_NAND3:=}"

: "${TRCH_SRAM_FILE0:=${RUN_DIR}/trch.sram0.bin}"
: "${TRCH_SRAM_FILE1:=${RUN_DIR}/trch.sram1.bin}"
: "${TRCH_SRAM_FILE2:=${RUN_DIR}/trch.sram2.bin}"
: "${TRCH_SRAM_FILE3:=${RUN_DIR}/trch.sram3.bin}"
: "${TRCH_NAND_FILE0:=${RUN_DIR}/trch.nand0.bin}"
: "${TRCH_NAND_FILE1:=${RUN_DIR}/trch.nand1.bin}"
: "${TRCH_NAND_FILE2:=${RUN_DIR}/trch.nand2.bin}"
: "${TRCH_NAND_FILE3:=${RUN_DIR}/trch.nand3.bin}"
: "${HPPS_NAND_FILE0:=${RUN_DIR}/hpps.nand0.bin}"
: "${HPPS_NAND_FILE1:=${RUN_DIR}/hpps.nand1.bin}"
: "${HPPS_NAND_FILE2:=${RUN_DIR}/hpps.nand2.bin}"
: "${HPPS_NAND_FILE3:=${RUN_DIR}/hpps.nand3.bin}"
: "${HPPS_SRAM_FILE0:=${RUN_DIR}/hpps.sram0.bin}"
: "${HPPS_SRAM_FILE1:=${RUN_DIR}/hpps.sram1.bin}"
: "${HPPS_SRAM_FILE2:=${RUN_DIR}/hpps.sram2.bin}"
: "${HPPS_SRAM_FILE3:=${RUN_DIR}/hpps.sram3.bin}"

: "${TRCH_SRAM_FILE0_PFLASH_INDEX:=0}"
: "${TRCH_SRAM_FILE1_PFLASH_INDEX:=1}"
: "${TRCH_SRAM_FILE2_PFLASH_INDEX:=2}"
: "${TRCH_SRAM_FILE3_PFLASH_INDEX:=3}"
: "${TRCH_NAND_FILE0_PFLASH_INDEX:=4}"
: "${TRCH_NAND_FILE1_PFLASH_INDEX:=5}"
: "${TRCH_NAND_FILE2_PFLASH_INDEX:=6}"
: "${TRCH_NAND_FILE3_PFLASH_INDEX:=7}"
: "${HPPS_SRAM_FILE0_PFLASH_INDEX:=8}"
: "${HPPS_SRAM_FILE1_PFLASH_INDEX:=9}"
: "${HPPS_SRAM_FILE2_PFLASH_INDEX:=10}"
: "${HPPS_SRAM_FILE3_PFLASH_INDEX:=11}"
: "${HPPS_NAND_FILE0_PFLASH_INDEX:=12}"
: "${HPPS_NAND_FILE1_PFLASH_INDEX:=13}"
: "${HPPS_NAND_FILE2_PFLASH_INDEX:=14}"
: "${HPPS_NAND_FILE3_PFLASH_INDEX:=15}"

: "${MAC_ADDR:=00:0a:35:00:02:$ID}"
# This target IP is for 'user' networking mode, where the address is private,
# all instances can use the same address.
: "${TARGET_IP:=10.0.2.15}"

: "${SSH_TARGET_PORT:=22}"
: "${DEBUG_TARGET_PORT:=2345}"

# These can be increased by modifying the number here without any issue;
# they only exist in order to keep the ports for each instance together.
MAX_INSTANCES=8
MAX_FWD_PORTS=4

: "${PORT_BASE:=$((1024 + $(id -u) + 1000))}" # arbitrary, but unique and not system
: "${QMP_PORT:=$((PORT_BASE + 0 * MAX_INSTANCES + ID))}"
: "${GDB_PORT:=$((PORT_BASE + 1 * MAX_INSTANCES + ID))}"
: "${FWD_PORT_BASE:=$((PORT_BASE + 2 * MAX_INSTANCES * MAX_FWD_PORTS + ID))}"

: "${SERIAL_ID:=$ID}"

# A fixed HW characteristic, not overridable
# Labels are created by Qemu with the convention "serialN"
SERIAL_PORTS=(serial0 serial1 serial2)

set_default SERIAL_PORT_NAMES[serial0] "lsio0"
set_default SERIAL_PORT_NAMES[serial1] "lsio1"
set_default SERIAL_PORT_NAMES[serial2] "hpps"

declare -A SCREEN_SESSIONS
SERIAL_PORT_ARGS=()
for p in "${SERIAL_PORTS[@]}"
do
    if [ ! -z "${SERIAL_PORT_NAMES[$p]}" ] # empty name means disabled
    then
        SCREEN_SESSIONS[$p]="hpsc-$SERIAL_ID-${SERIAL_PORT_NAMES[$p]}"
        SERIAL_PORT_ARGS+=(-serial pty)
    else
        SERIAL_PORT_ARGS+=(-serial null)
    fi
done

RUN=0
echo "CMD: ${CMD}"
case "${CMD}" in
   run)
        create_images
        setup_console
        RUN=1
        ;;
   gdb)
        # setup/attach_consoles are called when gdb runs this script with "consoles"
        # cmd from the hook to the "run" command defined below:

        if [ "$RESET" -eq 1 ]
        then
            RESET_ARG=""
        else
            RESET_ARG="-S"
        fi

        # NOTE: have to go through an actual file because -ex doesn't work since no way
        ## to give a multiline command (incl. multiple -ex), and bash-created file -x
        # <(echo -e ...) doesn't work either (issue only with gdb).
        GDB_CMD_FILE=$(mktemp)
        cat >/"$GDB_CMD_FILE" <<EOF
define hook-run
shell $0 $RESET_ARG gdb_run
end
EOF
        GDB_ARGS=(gdb -x "$GDB_CMD_FILE" --args)
        RUN=1
        ;;
    gdb_run)
        create_images
        setup_console
        ;;
esac

if [ "$RUN" -eq 0 ]
then
    exit
fi

# Compose qemu commands according to the command options.
# Build the command as an array of strings. Quote anything with a path variable
# or that uses commas as part of a string instance. Building as a string and
# using eval on it is error-prone, e.g., if spaces are introduced to parameters.
#
# See QEMU User Guide in HPSC release for explanation of the command line arguments
# Note: order of -device args may matter, must load ATF last, because loader also sets PC
# Note: If you want to see instructions and exceptions at a large performance cost, then add
# "in_asm,int" to the list of categories in -d.

COMMAND=("${GDB_ARGS[@]}" "qemu-system-aarch64"
    -machine "arm-generic-fdt"
    -m ${MAX_VM_MEM}
    -nographic
    -qmp "telnet::$QMP_PORT,server,nowait"
    -S
    -D "${LOG_FILE}" -d "fdt,guest_errors,unimp,cpu_reset"
    -hw-dtb "${QEMU_DT_FILE}"
    "${SERIAL_PORT_ARGS[@]}"
    -drive "file=$HPPS_NAND_FILE0,if=pflash,format=raw,index=$HPPS_NAND_FILE0_PFLASH_INDEX"
    -drive "file=$HPPS_SRAM_FILE0,if=pflash,format=raw,index=$HPPS_SRAM_FILE0_PFLASH_INDEX"
    -drive "file=$TRCH_SRAM_FILE0,if=pflash,format=raw,index=$TRCH_SRAM_FILE0_PFLASH_INDEX"
    "${QEMU_ARGS[@]}")

if [[ ! -z "${GDB_PORT}" && "${GDB_PORT}" != "none" ]] # ugly due to positive default
then
    COMMAND+=(-gdb "tcp::$GDB_PORT")
fi

NET_NIC=(-net "nic,vlan=0,macaddr=$MAC_ADDR")
case "${NET}" in
tap)
    # See HPSC Qemu User Guide for setup. In short, do this once, as root:
    #     ip link add $BRIDGE type bridge
    #     echo "allow $BRIDGE" >> /usr/local/etc/qemu/bridge.conf
    #     install -o root -g root -m 4775 /usr/local/bin/qemu-bridge-helper $QEMU_BRIDGE_PREFIX
    COMMAND+=("${NET_NIC[@]}" -net "tap,vlan=0,br=$BRIDGE,helper=qemu-bridge-helper")
    ;;
user)
    if [[ "${#FWD_PORTS[@]}" -gt $MAX_FWD_PORTS ]]
    then
        echo "ERROR: too many forward ports, increase MAX_FWD_PORTS in $0" 2>&1
        exit 1
    fi
    i=0
    for port in "${FWD_PORTS[@]}"
    do
        FWD_HOST_PORT=$((FWD_PORT_BASE+i))
        PORT_FWD_ARGS+=",hostfwd=tcp:$HOST_BIND_IP:$FWD_HOST_PORT-$TARGET_IP:$port"
        FWD_PORTS_INFO+="$HOST_BIND_IP:$FWD_HOST_PORT-$TARGET_IP:$port\n"
        i=$((i + 1))
    done
    COMMAND+=("${NET_NIC[@]}" -net "user,vlan=0$PORT_FWD_ARGS")
    ;;
none)
    ;;
*)
    echo "ERROR: invalid networking config choice: $NET" 1>&2
    exit 1
    ;;
esac

if [ "$MONITOR" -eq 1 ]
then
    COMMAND+=(-monitor stdio)
fi

if [ ${#MEMORY_FILES[@]} -gt 0 ]
then
    for f in "${MEMORY_FILES[@]}"
    do
        preload_memory "$f"
    done
fi

echo "Final Command (one arg per line):"
for arg in "${COMMAND[@]}"
do
    echo "$arg"
done
echo

echo "Final Command:"
echo "${COMMAND[*]}"
echo

echo "QMP_PORT = ${QMP_PORT}"
echo "GDB_PORT = ${GDB_PORT}"

if [ "${NET}" = "user" ]
then
    echo "FORWARDED PORTS:"
    echo -e "$FWD_PORTS_INFO"
fi
echo

# Make it so!
"${COMMAND[@]}"
