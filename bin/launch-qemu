#!/bin/bash

# Construct the QEMU command line and invoke it
#
# Expects SDK to have been activated by loading
# the SDK env.sh script into the shell.
#
# Dependencies:
#   * screen : for display of forwarded serial UART ports
#   * Python 3: with the following modules
#      - telnetlib : for communication with Qemu via QMP interface
#      - json : for QMP

SCRIPT_DIR=$(dirname ${BASH_SOURCE})

source ${SCRIPT_DIR}/launch.sh

function finish {
    if [ -n "$GDB_CMD_FILE" ]
    then
        rm "$GDB_CMD_FILE"
    fi
    if [[ $KILL_CONSOLES -eq 1 && ! -z "$CONSOLES_PID" ]]
    then
        if ps -p "$CONSOLES_PID" >/dev/null 2>&1
        then
            kill "$CONSOLES_PID"
        fi
    fi
}
trap finish EXIT

function usage()
{
    echo "Usage: $0 [-hSq] [-d dt_file] [-e env]*  [-l categories] [-m mem] [-n netcfg [-p port]*] [ cmd ]" 1>&2
    echo "               cmd: command" 1>&2
    echo "                    run - start emulation (default)" 1>&2
    echo "                    gdb - launch the emulator in GDB" 1>&2
    echo "               -d dt_file: Qemu device tree file that defines the machine" 1>&2
    echo "               -e env: load environment settings from file" 1>&2
    echo "               -l categories: comma-separated categories to log in Qemu log (e.g. "asm_in,int") " 1>&2
    echo "               -m memory map: preload files into memory" 1>&2
    echo "               -n netcfg : choose networking configuration" 1>&2
    echo "                   user: forward a port on the host to the target NIC" 1>&2
    echo "                   tap: create a host tunnel interface to the target NIC (requires root)" 1>&2
    echo "               -p port: in 'user' networking config, forward port to host" 1>&2
    echo "                    (script prints host port assigned to each forwarded port)" 1>&2
    echo "               -S : wait for GDB or QMP connection instead of resetting the machine" 1>&2
    echo "               -q : do not enable the Qemu monitor prompt" 1>&2
    echo "               -h : show this message" 1>&2
    exit 1
}

function setup_screen()
{
    local SESSION=$1

    if [ "$(screen -list "$SESSION" | grep -c "$SESSION")" -gt 1 ]
    then
        # In case the user somehow ended up with more than one screen process,
        # kill them all and create a fresh one.
        echo "Found multiple screen sessions matching '$SESSION', killing..."
        screen -list "$SESSION" | grep "$SESSION" | \
            sed -n "s/\([0-9]\+\).$SESSION\s\+.*/\1/p" | xargs kill
    fi

    # There seem to be some compatibility issues between Linux distros w.r.t.
    # exit codes and behavior when using -r and -q with -ls for detecting if a
    # user is attached to a session, so we won't bother trying to wait for them.
    screen -q -list "$SESSION"
    # it's at least consistent that no matching screen sessions gives $? < 10
    if [ $? -lt 10 ]
    then
        echo "Creating screen session with console: $SESSION"
        screen -d -m -S "$SESSION"
    fi
}

function serial_ptys()
{
    qmp.py -q localhost "$QMP_PORT" query-chardev | \
        qemu-chardev-ptys "${!SCREEN_SESSIONS[@]}"
}

function attach_consoles()
{
    echo "Waiting for Qemu to open QMP port and to query for PTY paths..."
    #while test $(lsof -ti :$QMP_PORT | wc -l) -eq 0
    while true
    do
        PTYS="$(serial_ptys 2>/dev/null)"
        if [ -z "$PTYS" ]
        then
            #echo "Waiting for Qemu to open QMP port..."
            sleep 1
            ATTEMPTS+=" 1 "
            if [ "$(echo "$ATTEMPTS" | wc -w)" -eq 10 ]
            then
                echo "ERROR: failed to get PTY paths from Qemu via QMP port: giving up."
                echo "Here is what happened when we tried to get the PTY paths:"
                set -x
                serial_ptys
                exit # give up to not accumulate waiting processes
            fi
        else
            break
        fi
    done

    declare -A "PTYS_DICT=$PTYS" # port label => desired session name
    for p in ${!PTYS_DICT[@]}
    do
        # Need to start a new single-use $pty_sess screen session outside of the
        # persistent $sess one, then attach to $pty_sess from within $sess.
        # This is needed if $sess was previously attached, then detached (but
        # not terminated) after QEMU exited.
        local pty="${PTYS_DICT[$p]}"
        local sess="${SCREEN_SESSIONS[$p]}"
        local pty_sess="hpsc-pts$(basename "$pty")"
        local SCROLLBACK=1000000
        echo "Adding console $pty for port $p to screen session $sess"
        screen -d -m -S "$pty_sess" "$pty"
        screen -S "$pty_sess" -X scrollback $SCROLLBACK
        screen -S "$sess" -X scrollback $SCROLLBACK
        # TODO: Make this work without using "stuff" command
        screen -S "$sess" -X stuff "^C screen -m -r $pty_sess\r"
        sleep 1 # give the above command time to execute
        echo "Attach to screen session from another window with:"
        echo "  screen -r $sess"
    done

    echo "Commanding Qemu to reset the machine..."
    if [ "$RESET" -eq 1 ]
    then
        echo "Sending 'continue' command to Qemu to reset the machine..."
        qmp.py localhost "$QMP_PORT" cont
    else
        echo "Waiting for 'continue' (aka. reset) command via GDB or QMP connection..."
    fi
}

setup_console()
{
    for session in "${SCREEN_SESSIONS[@]}"
    do
        setup_screen "$session"
    done
    attach_consoles &
    CONSOLES_PID=$!
}

preload_memory()
{
    set -e
    local map_file=$1
    echo "Preloading memory according to map file: $map_file"
    if [ ! -r "${map_file}" ] # 'while...done < file' not fatal even with set -e
    then
        echo "ERROR: can't read preload memory map file: $map_file" 1>&2
        return 1
    fi
    declare -A SEGMENT_ADDRS
    declare -A SEGMENT_FILES
    local line_num=0
    while read line
    do
        local HASH="#" # workaround for vim syntax highlightin breaking
        if [[ "$line" =~ ^\s*$ || "$line" =~ ^[[:space:]]*$HASH ]]
        then
            continue
        fi
        line=$(echo "$line" | sed 's/\(.*\)\s*#.*/\1/')
        local WORDS=($line)

        local key=$(extract_word 0 "${WORDS[@]}")
        local addr_spec=$(extract_word 1 "${WORDS[@]}")
        local in_file=$(eval echo "$(extract_word 2 "${WORDS[@]}")") # expand vars

        if [[ -z "$key" || -z "$addr_spec" || -z "$in_file" ]]
        then
            echo "ERROR: syntax error on line $line_num" 1>&2
            exit 2
        fi

        # Address field can be: 0x00000000, 0x0000_0000, after(name), -, 4:<any of the above>
        addr_spec=$(echo "$addr_spec" | sed 's/(/\[/g' | sed 's/)/\]/g') # ()->[] for eval
        addr_spec=$(eval echo "$addr_spec")
        addr_spec=$(echo "$addr_spec" | sed 's/_//g')
        local cpu="$(echo "$addr_spec" | sed -n 's/^\([0-9]\+\):.*/\1/p')" # may be empty
        addr_spec="$(echo "$addr_spec" | sed -n 's/^\([0-9]\+:\)\?\(.*\)/\2/p')"
        local ref_seg=$(echo "$addr_spec" | sed -n 's/^after\[\([^)]\+\)\]/\1/p')
        if [ ! -z "$ref_seg" ]
        then
            local addr=$(hex $((${SEGMENT_ADDRS[$ref_seg]} + $(stat -c '%s' "${SEGMENT_FILES[$ref_seg]}"))))
        else
            if [[ "$addr_spec" =~ - ]]
            then  # do not supply addr
                local addr=
            else
                local addr=$(parse_addr "$(echo "$addr_spec" | sed -n 's/^\(0x\)\?\([0-9A-Fa-f]\+\)/\1\2/p')")
            fi
        fi
        SEGMENT_ADDRS["$key"]="$addr"
        SEGMENT_FILES["$key"]="$in_file"

        local loader_arg="loader,file=$in_file"
        if [ ! -z "$cpu" ]
        then
            loader_arg+=",cpu-num=$cpu"
        fi
        if [ ! -z "$addr" ]
        then
            loader_arg+=",force-raw,addr=$addr"
        fi
        COMMAND+=(-device "$loader_arg")

        line_num=$((line_num + 1))
    done < "$map_file"
    set +e
}

create_images()
{
    set -e
    for p in $SMC_SRAM_PORTS_IDXS
    do
        init_smc_sram_img HPPS_SMC_SRAM_${p}
        init_smc_sram_img LSIO_SMC_SRAM_${p}
    done
    for p in $SMC_NAND_PORTS_IDXS
    do
        init_smc_nand_img HPPS_SMC_NAND_${p}
        init_smc_nand_img LSIO_SMC_NAND_${p}
    done
    set +e
}

# defaults
RESET=1
NET=none
MONITOR=1
FWD_PORTS=()
MEMORY_FILES=() # order matters, since loader may also set CPU's PC
ENV_FILES=("${PWD}/qemu-env.sh")
LOG_CATEGORIES="fdt,guest_errors,unimp,cpu_reset"

# parse options
while getopts "h?S?q?e:d:l:m:p:n:" o; do
    case "${o}" in
        S)
            RESET=0
            ;;
        d)
            QEMU_DT_FILE="$OPTARG"
            ;;
        e)
            ENV_FILES+=("$OPTARG")
            ;;
        p)
            FWD_PORTS+=("$OPTARG")
            ;;
        l)
            LOG_CATEGORIES+=",$OPTARG"
            ;;
        m)
            MEMORY_FILES+=("$OPTARG")
            ;;
        n)
            NET="$OPTARG"
            ;;
        q)
            MONITOR=0
            ;;
        h)
            usage
            ;;
        *)
            echo "Wrong option" 1>&2
            usage
            ;;
    esac
done
shift $((OPTIND-1))
CMD=$*

if [ -z "${CMD}" ]
then
    CMD="run"
fi

## Hardware parameters that are fixed in the HW design (not configurable)

# Serial port labels are created by Qemu with the convention "serialN"
SERIAL_PORTS=(serial0 serial1 serial2)

# Ports assumed to be the same across all SMC instances in the SoC
SMC_SRAM_PORTS=4
SMC_NAND_PORTS=2

SMC_SRAM_PORTS_IDXS=$(seq 0 $(($SMC_SRAM_PORTS - 1)))
SMC_NAND_PORTS_IDXS=$(seq 0 $(($SMC_NAND_PORTS - 1)))

## Configurable params of array types (must be inited before loading env)
#
# Note: all are overridable in an env.sh file.
# Note: params of array types are not overridable via environment variables.

declare -A SERIAL_PORT_NAMES

for p in $SMC_SRAM_PORTS_IDXS
do
    declare -A LSIO_SMC_SRAM_${p}
    declare -A HPPS_SMC_SRAM_${p}
done
for p in $SMC_NAND_PORTS_IDXS
do
    declare -A LSIO_SMC_NAND_${p}
    declare -A HPPS_SMC_NAND_${p}
done

# Load env file which may override any of the above defaults
for qemu_env in "${ENV_FILES[@]}"
do
    source_if_exists "${qemu_env}"
done

## Default values for various params applied if not set (neither by the env
# file nor by environment variables).

# Privatize ports and screen sessions for this Qemu instance
: "${ID:=0}"

# Memory images created by this script will go here
: "${RUN_DIR:=.}"

: "${LOG_FILE:=/tmp/qemu-$(whoami).log}"
: "${BRIDGE:=br0}"
: "${HOST_BIND_IP:=127.0.0.1}"

# This maximum is respected by Qemu, regardless of what memory is defined in
# Qemu device tree (e.g. generic-loader will fail to load a file that exceeds
# this maximum, even if DT defines larger memory).
: "${MAX_VM_MEM:=4G}"

: "${MAC_ADDR:=00:0a:35:00:02:$ID}"
# This target IP is for 'user' networking mode, where the address is private,
# all instances can use the same address.
: "${TARGET_IP:=10.0.2.15}"

: "${SSH_TARGET_PORT:=22}"
: "${DEBUG_TARGET_PORT:=2345}"

# These can be increased by modifying the number here without any issue;
# they only exist in order to keep the ports for each instance together.
MAX_INSTANCES=8
MAX_FWD_PORTS=4

: "${PORT_BASE:=$((1024 + $(id -u) + 1000))}" # arbitrary, but unique and not system
: "${QMP_PORT:=$((PORT_BASE + 0 * MAX_INSTANCES + ID))}"
: "${GDB_PORT:=$((PORT_BASE + 1 * MAX_INSTANCES + ID))}"
: "${FWD_PORT_BASE:=$((PORT_BASE + 2 * MAX_INSTANCES * MAX_FWD_PORTS + ID))}"

: "${SERIAL_ID:=$ID}"

set_default SERIAL_PORT_NAMES[serial0] "lsio0"
set_default SERIAL_PORT_NAMES[serial1] "lsio1"
set_default SERIAL_PORT_NAMES[serial2] "hpps"

# Default NV mem parameters
#
# Note: no defaults for size, and for NAND layout params (page, oob, ecc, ppb),
# because the launch scripts are not a good place for them, because for some
# targets they are fixed by HW design; must be defined in env file.
for p in $SMC_SRAM_PORTS_IDXS
do
    set_default LSIO_SMC_SRAM_${p}[run] "${RUN_DIR}/lsio.sram.${p}.bin"
    set_default HPPS_SMC_SRAM_${p}[run] "${RUN_DIR}/hpps.sram.${p}.bin"
done
for p in $SMC_NAND_PORTS_IDXS
do
    set_default LSIO_SMC_NAND_${p}[run] "${RUN_DIR}/lsio.nand.${p}.bin"
    set_default HPPS_SMC_NAND_${p}[run] "${RUN_DIR}/hpps.nand.${p}.bin"
done

# May be referenced in memory map files to be loaded below
RUN=$(realpath ${RUN_DIR})

## Actions commence here

mkdir -p "${RUN_DIR}"

declare -A SCREEN_SESSIONS
SERIAL_PORT_ARGS=()
for p in "${SERIAL_PORTS[@]}"
do
    if [ ! -z "${SERIAL_PORT_NAMES[$p]}" ] # empty name means disabled
    then
        SCREEN_SESSIONS[$p]="hpsc-$SERIAL_ID-${SERIAL_PORT_NAMES[$p]}"
        SERIAL_PORT_ARGS+=(-serial pty)
    else
        SERIAL_PORT_ARGS+=(-serial null)
    fi
done

DO_RUN=0
KILL_CONSOLES=1
echo "CMD: ${CMD}"
case "${CMD}" in
   run)
        create_images
        setup_console
        DO_RUN=1
        ;;
   gdb)
        # setup/attach_consoles are called when gdb runs this script with "consoles"
        # cmd from the hook to the "run" command defined below:

        NESTED_ARGS=()
        if [ "$RESET" -eq 0 ]
        then
            NESTED_ARGS+=(-S)
        fi

        for f in "${ENV_FILES[@]}"
        do
            NESTED_ARGS+=(-e "$f")
        done

        # NOTE: have to go through an actual file because -ex doesn't work since no way
        ## to give a multiline command (incl. multiple -ex), and bash-created file -x
        # <(echo -e ...) doesn't work either (issue only with gdb).
        GDB_CMD_FILE=$(mktemp)
        cat >/"$GDB_CMD_FILE" <<EOF
define hook-run
shell "$0" ${NESTED_ARGS[@]} gdb_run
end
EOF
        GDB_ARGS=(gdb -x "$GDB_CMD_FILE" --args)
        DO_RUN=1
        ;;
    gdb_run)
        create_images
        setup_console
        KILL_CONSOLES=0
        ;;
esac

if [ "$DO_RUN" -eq 0 ]
then
    exit
fi

# Compose qemu commands according to the command options.
# Build the command as an array of strings. Quote anything with a path variable
# or that uses commas as part of a string instance. Building as a string and
# using eval on it is error-prone, e.g., if spaces are introduced to parameters.
#
# See QEMU User Guide in HPSC release for explanation of the command line
# arguments.

# TODO: support all ports in Qemu
#for p in $SMC_SRAM_PORTS_IDXS
#for p in $SMC_NAND_PORTS_IDXS
#
DRIVE_ARGS=(
    -drive "file=${HPPS_SMC_NAND_0[run]},if=pflash,format=raw,index=3"
    -drive "file=${HPPS_SMC_SRAM_0[run]},if=pflash,format=raw,index=2"
    -drive "file=${LSIO_SMC_NAND_0[run]},if=pflash,format=raw,index=1"
    -drive "file=${LSIO_SMC_SRAM_0[run]},if=pflash,format=raw,index=0"
)

COMMAND=("${GDB_ARGS[@]}" "qemu-system-aarch64"
    -machine "arm-generic-fdt"
    -m ${MAX_VM_MEM}
    -nographic
    -qmp "telnet::$QMP_PORT,server,nowait"
    -S
    -D "${LOG_FILE}" -d "$LOG_CATEGORIES"
    -hw-dtb "${QEMU_DT_FILE}"
    "${SERIAL_PORT_ARGS[@]}"
    "${DRIVE_ARGS[@]}"
    "${QEMU_ARGS[@]}")

if [[ ! -z "${GDB_PORT}" && "${GDB_PORT}" != "none" ]] # ugly due to positive default
then
    COMMAND+=(-gdb "tcp::$GDB_PORT")
fi

# We have to use the legacy "-net nic" option because that's the only way to
# associate the network device instantiated via the device tree to a backend.
# As far as instantiating a backend, we do have the choice of using "-netdev
# X,id=ND" (with "-net nic,netdev=ND") or "-net X" (with "-net nic"), the
# latter implicitly creates a switch and associates both the backend and the
# NIC to that switch. We use the latter option.
NET_NIC=(-net "nic,macaddr=$MAC_ADDR")
case "${NET}" in
tap)
    # See HPSC Qemu User Guide for setup. In short, do this once, as root:
    #     ip link add $BRIDGE type bridge
    #     echo "allow $BRIDGE" >> /usr/local/etc/qemu/bridge.conf
    #     install -o root -g root -m 4775 /usr/local/bin/qemu-bridge-helper $QEMU_BRIDGE_PREFIX
    COMMAND+=("${NET_NIC[@]}" -net "tap,br=$BRIDGE,helper=qemu-bridge-helper")
    ;;
user)
    if [[ "${#FWD_PORTS[@]}" -gt $MAX_FWD_PORTS ]]
    then
        echo "ERROR: too many forward ports, increase MAX_FWD_PORTS in $0" 2>&1
        exit 1
    fi
    i=0
    for port in "${FWD_PORTS[@]}"
    do
        FWD_HOST_PORT=$((FWD_PORT_BASE+i))
        PORT_FWD_ARGS+=",hostfwd=tcp:$HOST_BIND_IP:$FWD_HOST_PORT-$TARGET_IP:$port"
        FWD_PORTS_INFO+="$HOST_BIND_IP:$FWD_HOST_PORT-$TARGET_IP:$port\n"
        i=$((i + 1))
    done
    COMMAND+=("${NET_NIC[@]}" -net "user$PORT_FWD_ARGS")
    ;;
none)
    ;;
*)
    echo "ERROR: invalid networking config choice: $NET" 1>&2
    exit 1
    ;;
esac

if [ "$MONITOR" -eq 1 ]
then
    COMMAND+=(-monitor stdio)
fi

if [ ${#MEMORY_FILES[@]} -gt 0 ]
then
    for f in "${MEMORY_FILES[@]}"
    do
        preload_memory "$f"
    done
fi

echo "Final Command (one arg per line):"
for arg in "${COMMAND[@]}"
do
    echo "$arg"
done
echo

echo "Final Command:"
echo "${COMMAND[*]}"
echo

echo "QMP_PORT = ${QMP_PORT}"
echo "GDB_PORT = ${GDB_PORT}"

if [ "${NET}" = "user" ]
then
    echo "FORWARDED PORTS:"
    echo -e "$FWD_PORTS_INFO"
fi
echo

# Make it so!
"${COMMAND[@]}"
